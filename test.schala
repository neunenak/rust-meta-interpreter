
fn main() {

# comments are scripting-style
#{ but can also be

}# blocks

@annotations are with @-

# variable expressions
  var a: I32 = 20
  const b: String = 20

  there(); can(); be(); multiple(); statements(); per_line();

  #string interpolation
  const yolo = "I have ${a + b} people in my house"

  # let expressions ??? not sure if I want this
  let a = 10, b = 20, c = 30 in a + b + c

  #list literal
  const q = [1,2,3,4]

  #lambda literal ?? maybe? not sure how this should work
  q.map(|item| { item * 100 })

  fn yolo(a: MyType, b: YourType): ReturnType<Param1, Param2> {
    if a == 20 {
      return "early"
    }
    var sex = 20
    sex
  }


  for {
  # infinite loop
  }

  #iteration over a variable
  for i <- [1..1000]  {

  }

  #while loop
  for a != 3 || fuckTard() {
    break
  }

  #monadic decomposition
  for a <- maybeInt(); s <- foo() {
    a + s
  }

  # let statements too!!
  for (a = 20
  b = fuck) {
    a + b
  }


  # pattern-matching
  match <expr> {
    Some(a) => {

    },
    None => {

    },
  }

 #syntax is, I guess, for <expr> <brace-block>, where <expr> is a bool, or a <arrow-expr>

 # type level alises
 typealias <name> = <other type>
 
 #declaring types of all stripes
 type MyData = { a: i32, b: String }
 type MyType = MyType
 type Option<a> = None | Some(a)
 type Signal = Absence | SimplePresence(i32) | ComplexPresence {a: i32, b: MyCustomData}

 #traits
 
 trait Bashable { }
 trait Luggable {
  fn lug(self, a: Option<Self>)
 }

}
